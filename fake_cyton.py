import asyncio
import csv
import math
import os
import pty
import struct

# ----------------------------------------------------------------------
# CytonDataConverter
# ----------------------------------------------------------------------

class CytonDataConverter(object):
    """
    Converts csv output of OpenBCI_Python library to approximate format 
    of data as it was originally generated by the Cyton headboard.
    """

    # These values were copied from OpenBCI_Python's cyton.py file.
    # (see https://github.com/OpenBCI/OpenBCI_Python/blob/master/openbci/cyton.py#L34)
    START_BYTE = b'\xa0'
    END_BYTE = b'\xc0'
    ADS1299_Vref = 4.5  # reference voltage for ADC in ADS1299.  set by its hardware
    ADS1299_gain = 24.0  # assumed gain setting for ADS1299.  set by its Arduino code
    scale_fac_uVolts_per_count = ADS1299_Vref / \
        float((pow(2, 23) - 1)) / ADS1299_gain * 1000000.
    scale_fac_accel_G_per_count = 0.002 / \
        (pow(2, 4))  # assume set to +/4G, so 2 mG

    def __init__(self, filename):
        self.rows = []
        with open(filename) as fh:
            reader = csv.reader(fh)
            for raw_row in reader:
                row = [column.strip() for column in raw_row]
                iden = struct.pack('B', int(row[0]))
                # Convert microvolts to the values originally reported
                # by the headset.
                channel_data = [self._channel_data(i) for i  in row[1:9]]
                # Convert Gs to the values originally reported by
                # the headset.
                accel_data = [self._accelerometer_data(i) for i in row[9:12]]
                vals = [iden] + channel_data + accel_data
                self.rows.append(b''.join(vals))
        self.unsent_queue = self.rows.copy()
    
    def next_row(self):
        if len(self.unsent_queue) == 0:
            self.unsent_queue = self.rows.copy()
        return self.START_BYTE + self.unsent_queue.pop(0) + self.END_BYTE

    def _channel_data(self, microvolts):
        hardware_val = math.floor(float(microvolts)/self.scale_fac_uVolts_per_count)
        literal_read = struct.pack('>i', hardware_val)
        return literal_read[1:]

    def _accelerometer_data(self, g_val):
        hardware_val = math.floor(float(g_val)/self.scale_fac_accel_G_per_count)
        return struct.pack('>h', hardware_val)

# ----------------------------------------------------------------------
# FakeSerialDevice
# ----------------------------------------------------------------------

class FakeSerialDevice(object):
    """
    Exposes a `port` that behaves like a serial device.
    """
    
    def __init__(self):
        self.master, slave = pty.openpty()
        self.port = os.ttyname(slave)
        self.reader = None
        self.writer = None

    async def setup_reader(self, loop):

        # Create reader
        # (see https://gist.github.com/oconnor663/08c081904264043e55bf)
        self.reader = asyncio.StreamReader()
        read_protocol = asyncio.StreamReaderProtocol(self.reader)
        await loop.connect_read_pipe(lambda: read_protocol, os.fdopen(self.master))

    async def setup_writer(self, loop):

        # Create writer
        # (see https://gist.github.com/oconnor663/08c081904264043e55bf)
        write_protocol = asyncio.StreamReaderProtocol(asyncio.StreamReader())
        write_transport, _ = await loop.connect_write_pipe(
                            lambda: write_protocol, os.fdopen(self.master, 'w'))
        self.writer = asyncio.StreamWriter(write_transport, write_protocol, None, loop)

    def teardown_writer(self):
        self.writer.close()
        self.writer = None

    async def read(self):
        return await self.reader.read(1)

    def write(self, output):
        self.writer.write(output)

# ----------------------------------------------------------------------
# Runner
# ----------------------------------------------------------------------

class Runner(object):

    START_CMD = b'b'
    STOP_CMD = b's'

    def __init__(self, sample_path):
        self.sample_path = sample_path
        self.write_task = None
        self.board = FakeSerialDevice()

    async def start_listening(self):

        loop = asyncio.get_event_loop()

        await self.board.setup_reader(loop)

        print(f"Connect @ {self.board.port}")

        while True:
            val = await self.board.read()
            if val == self.START_CMD:
                self.write_task = asyncio.create_task(self._start_output())
            elif val == self.STOP_CMD and self.write_task is not None:
                self._stop_output()

    async def _start_output(self):
        print("Will start...")
        loop = asyncio.get_event_loop()
        await self.board.setup_writer(loop)
        converter = CytonDataConverter(self.sample_path)
        while True:
            self.board.write(converter.next_row())
            await asyncio.sleep(0.1)

    def _stop_output(self):
        self.board.teardown_writer()
        self.write_task.cancel()
        print("...did stop")

# ----------------------------------------------------------------------
# main
# ----------------------------------------------------------------------

if __name__ == '__main__':
    runner = Runner('sample-cyton.csv')
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(runner.start_listening())
    finally:
        loop.close()
        exit(0)
